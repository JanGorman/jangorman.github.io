<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Jan Gorman]]></title>
  <link href="http://JanGorman.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://JanGorman.github.io/"/>
  <updated>2015-08-26T12:14:31+02:00</updated>
  <id>http://JanGorman.github.io/</id>
  <author>
    <name><![CDATA[Jan Gorman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Providers]]></title>
    <link href="http://JanGorman.github.io/blog/2015/08/26/providers/"/>
    <updated>2015-08-26T11:42:40+02:00</updated>
    <id>http://JanGorman.github.io/blog/2015/08/26/providers</id>
    <content type="html"><![CDATA[<p>As you&rsquo;ll know watchOS 2 allows you to create your own <a href="https://developer.apple.com/library/prerelease/watchos/documentation/General/Conceptual/AppleWatch2TransitionGuide/CreatingaComplication.html#//apple_ref/doc/uid/TP40015234-CH10-SW1">complications</a>. One thing that really stood out to me is the idea of using providers instead of setting either text or images directly. There&rsquo;s the abstract base class <a href="https://developer.apple.com/library/prerelease/watchos/documentation/ClockKit/Reference/CLKTextProvider_class/index.html#//apple_ref/occ/cl/CLKTextProvider">CLKTextProvider</a> and <a href="https://developer.apple.com/library/prerelease/watchos/documentation/ClockKit/Reference/CLKImageProvider_class/index.html#//apple_ref/occ/cl/CLKImageProvider">CLKImageProvider</a> that you provide (boom) to your complication. It&rsquo;s the context in which the complication is rendered that decides on the actual on-screen representation of information.</p>

<p>So there&rsquo;s this app I used to work on that needs to display prices a lot. And depending on the context where this prices is displayed it renders differently. Sounds similar to what the complication does. So in a grossly oversimplified example, let&rsquo;s build something around providers using Swift:</p>

<pre><code class="swift">struct PriceTextProvider {

    let basePrice: Double
    let reducedPrice: Double
    let vat: Double

}
</code></pre>

<p>This is our base provider. I think this close to actually showing the prices on screen it&rsquo;s fine to be using <code>Double</code>. Otherwise use <code>Int</code> and divide by 100, always. Especially when crossing over system boundaries (APIs!) where you can never be sure of language specific rounding behaviour.</p>

<p>Next come our options on <em>what</em> we want to show using the new and great <code>OptionSetType</code>:</p>

<pre><code class="swift">struct PriceTextRenderOptions: OptionSetType {

    let rawValue: Int

    init(rawValue: Int) {
        self.rawValue = rawValue
    }

    static let Base = PriceTextRenderOptions(rawValue: 1)
    static let Reduced = PriceTextRenderOptions(rawValue: 2)
    static let Vat = PriceTextRenderOptions(rawValue: 4)
    static let BaseAndReduced = [Base, Reduced]
    static let FullPrice = [Base, Reduced, Vat]

}
</code></pre>

<p>And context:</p>

<pre><code class="swift">enum PriceTextContext {
    case Normal, Short
}
</code></pre>

<p>Of course we could also opt to just have a context enum that then actually decides which rendering options to use. Maybe we should, I&rsquo;m undecided.</p>

<p>And now the renderer:</p>

<pre><code class="swift">class PriceTextRenderer {

    let priceFormatter: NSNumberFormatter
    let vatFormatter: NSNumberFormatter

    init(priceFormatter: NSNumberFormatter, vatFormatter: NSNumberFormatter) {
        self.priceFormatter = priceFormatter
        self.vatFormatter = vatFormatter
    }

    func render(provider: PriceTextProvider, context: PriceTextContext, options: PriceTextRenderOptions) -&gt; NSAttributedString {
        let attributedPrice = NSMutableAttributedString(string: "")
        let glue = context == .Normal ? "\n" : " "

        if let basePrice = priceFormatter.stringFromNumber(NSNumber(double: provider.basePrice)) where options.contains(.Base) {
            let a = NSAttributedString(string: basePrice, attributes: [NSForegroundColorAttributeName: UIColor.greenColor()])
            attributedPrice.appendAttributedString(a)
        }
        if let reducedPrice = priceFormatter.stringFromNumber(NSNumber(double: provider.reducedPrice)) where options.contains(.Reduced) {
            let a = NSAttributedString(string: "\(glue)\(reducedPrice)", attributes: [NSForegroundColorAttributeName: UIColor.redColor()])
            attributedPrice.appendAttributedString(a)
        }
        if let vat = vatFormatter.stringFromNumber(NSNumber(double: provider.vat)) where options.contains(.Vat) {
            let a = NSAttributedString(string: "\(glue)\(vat)")
            attributedPrice.appendAttributedString(a)
        }

        return attributedPrice
    }

}
</code></pre>

<p>There&rsquo;s a few things going on here. So let&rsquo;s brake it down:</p>

<p>First we&rsquo;re supplying the renderer with our <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNumberFormatter_Class/">NSNumberFormatters</a>. Still I see people displaying prices without using formatters. Stop it, you&rsquo;re doing it wrong. Even if your designers or you insist on really specific formats (though I&rsquo;d always argue to rather go with the locale defaults), you can fine tune every last bit of the formatter to your liking.</p>

<p>Next up is the render method. You&rsquo;ll probably want to really fine tune this part. Ideas that come to mind are a <code>.Short</code> format that removes decimal places if appropriate, drops certain parts of the price and things like glue words that can be prepended or formatted in a specific way. E.g. <code>VAT: %s</code>. Or maybe work out the reduction in price and highlight that. People love a bargain.</p>

<p>So finally calling the whole thing:</p>

<pre><code class="swift">let locale = NSLocale(localeIdentifier: "de_DE")

let priceFormatter = NSNumberFormatter()
priceFormatter.numberStyle = .CurrencyStyle
priceFormatter.locale = locale

let vatFormatter = NSNumberFormatter()
vatFormatter.numberStyle = .PercentStyle
vatFormatter.locale = locale

let renderer = PriceTextRenderer(priceFormatter: priceFormatter, vatFormatter: vatFormatter)

let provider = PriceTextProvider(basePrice: 20.00, reducedPrice: 15.00, vat: 0.19)
renderer.render(provider, context: .Normal, options: [.Base, .Reduced, .Vat])
renderer.render(provider, context: .Short, options: [.Base, .Reduced])
</code></pre>

<p>Get the whole thing as a playground over at this <a href="https://gist.github.com/JanGorman/2a28acc110c8c9f38993">github gist</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Better MVC]]></title>
    <link href="http://JanGorman.github.io/blog/2015/01/14/better-mvc/"/>
    <updated>2015-01-14T21:25:14+01:00</updated>
    <id>http://JanGorman.github.io/blog/2015/01/14/better-mvc</id>
    <content type="html"><![CDATA[<p>I had been meaning to write this for a while now. And even if the examples are all in Swift (because shiny) the same can be applied to Objective-C code as well without any problem.</p>

<p>Slimming down your iOS view controllers is a big topic around the office and there was even an entire issue of <a href="http://www.objc.io/issue-1/">objc.io</a> centered around the topic (as well as another one on <a href="http://www.objc.io/issue-13/">architecture</a>).</p>

<p>We had also tried some <a href="http://www.objc.io/issue-13/mvvm.html">MVVM</a> as well as <a href="http://www.objc.io/issue-13/viper.html">Viper</a> (ok, being an avid Uncle Bob <a href="https://cleancoders.com">clean code</a> watcher and reader, I know this is about a lot more but imho doesn&rsquo;t apply too well to iOS apps since there is only <em>one</em> presenter) but neither of those models really stuck. If you look at what Wikipedia has to say about <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> you will notice that it mentions the model notifying its associated views and controllers. Aha! So why not try that:</p>

<pre><code class="swift">class SimpleView: UIView {
  …
  @IBOutlet weak var nameTextField: UITextField!
  weak var model: SimpleModel! {
      didSet {
          model.addObserver(self, forKeyPath: "name", options: .New, context: &amp;context)
      }
  }

  …

  override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, change: [NSObject:AnyObject],
                                       context: UnsafeMutablePointer&lt;Void&gt;) {
      if context == &amp;self.context {
          nameLabel.text = "Hi there, \(change[NSKeyValueChangeNewKey]!)"
      } else {
          super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
      }
  }

  @IBAction func didSubmit(sender: AnyObject) {
      controller.didSubmitName(nameTextField.text)
  }
}
</code></pre>

<p>The view takes care of all it&rsquo;s own presentation and not the controller (as you&rsquo;ll see in code most of the time). Now of course KVO can get pretty cumbersome when there are a lot of properties involved but you get the point. The controller has nothing to do with the presentation of the model and just received requests from the view to update the model. What does the controller look like?</p>

<pre><code class="swift">protocol SimpleController: class {

    func didSubmitName(name: String)

}

class SimpleViewController: UIViewController, SimpleController {

    let model = SimpleModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        let mainView = self.view as SimpleView
        mainView.controller = self
        mainView.model = model
    }

    func didSubmitName(name: String) {
        model.name = name
    }

}
</code></pre>

<p>Ok, very simple example indeed. What about something more involved:</p>

<pre><code class="swift">class AdvancedView: UIView, UserModelObserver, RemoteModelObserver {
    …
    weak var userModel: UserModel! {
        didSet {
            userModel.addObserver(self)
        }
    }
    weak var remoteModel: RemoteModel! {
        didSet {
            remoteModel.addObserver(self)
        }
    }
    …  
}
</code></pre>

<p>As you can see, the model implements two protocols this time and listens to two different models for changes. And again, the controller is very slim:</p>

<pre><code class="swift">class AdvancedViewController: UIViewController {

    let userModel = UserModel()
    let remoteModel = RemoteModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        let advancedView = view as AdvancedView
        advancedView.controller = self
        advancedView.userModel = userModel
        advancedView.remoteModel = remoteModel
    }

    func submit(#firstName: String, lastName: String) {
        userModel.firstName = firstName
        userModel.lastName = lastName
        userModel.validate()
    }

    func load() {
        remoteModel.load()
    }

}
</code></pre>

<p>Any validation logic is done inside the models (which makes it easily testable). Code for loading remote resources is also done in the model:</p>

<pre><code class="swift">func load() {
    if let URL = NSURL(string: Constants.URLString) {
        let session = NSURLSession.sharedSession()
        let task = session.dataTaskWithURL(URL) {
            (data, response, error) in
            if error != nil {
                println("Epic Fail")
                return
            }

            var jsonError: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments,
                    error: &amp;jsonError) as NSArray
            self.comments = json
            dispatch_async(dispatch_get_main_queue()) {
                self.notifyObservers()
            }
        }
        task.resume()
    }
}
</code></pre>

<p>I&rsquo;ve uploaded a sample project over on <a href="https://github.com/JanGorman/BetterMVC">github</a> including a third example of a <code>UITableViewController</code> and some test code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns in Swift: Adapter Pattern]]></title>
    <link href="http://JanGorman.github.io/blog/2014/12/01/design-patterns-in-swift-adapter-pattern/"/>
    <updated>2014-12-01T20:44:17+01:00</updated>
    <id>http://JanGorman.github.io/blog/2014/12/01/design-patterns-in-swift-adapter-pattern</id>
    <content type="html"><![CDATA[<p>Already December! Time for a new chapter on applying design patterns in Swift. This time it&rsquo;s the <a href="http://en.wikipedia.org/wiki/Adapter_pattern">Adapter Pattern&rsquo;s</a> turn. Good stuff! And simple!</p>

<p>So what is it and what can it do for you? The Adapter Pattern converts the interface of one class into another interface. That&rsquo;s it. And with this simple pattern you can let classes work together that otherwise couldn&rsquo;t.</p>

<p>So let&rsquo;s assume you have the following:</p>

<pre><code class="swift">protocol MusicPlayer {

    func insertMedia()
    func play()

}

class CassettePlayer: MusicPlayer {

    func insertMedia() {
        println("Insert mixtape")
    }

    func play() {
        println("Push down clunky button and play")
    }

}
</code></pre>

<p>Clearly, this kind if thing is only <a href="https://www.youtube.com/watch?v=dIm87r9lnD0">acceptable in the 80s</a>.</p>

<p>Fast forward to now, Spotify, beats, you name it. How do you travel back in time and get a client that accepts a <code>MusicPlayer</code> to stream and play a track? You adapt it:</p>

<pre><code class="swift">protocol MediaPlayer {

    func getMedia(title: String)
    func play()

}

class StreamingMediaPlayer: MediaPlayer {

    func getMedia(title: String) {
        println("Acquiring \(title) from the cloud")
    }

    func play() {
        println("Playing!")
    }

}

// MARK: Adapter in action

class StreamingMediaPlayerAdapter: MusicPlayer {

    let player: StreamingMediaPlayer

    init(player: StreamingMediaPlayer) {
        self.player = player
    }

    func insertMedia(title: String) {
        player.getMedia(title)
    }

    func play() {
        player.play()
    }

}
</code></pre>

<p>Jaws drop in amazement. But now consider your existing project that you want to spice up with some of that Swift. You&rsquo;ve written your amazing new classes, time to integrate with Objective-C. So you head over to <a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77">Using Swift with Cocoa and Objective-C</a> only to find that the new goodness doesn&rsquo;t all work. All of these aren&rsquo;t compatible with Objective-C:</p>

<ul>
<li>Generics</li>
<li>Tuples</li>
<li>Enumerations defined in Swift</li>
<li>Structures defined in Swift</li>
<li>Top-level functions defined in Swift</li>
<li>Global variables defined in Swift</li>
<li>Typealiases defined in Swift</li>
<li>Swift-style variadics</li>
<li>Nested types</li>
<li>Curried functions</li>
</ul>


<p>Not to despair though, you can still go ahead and be as idiomatic in Swift as you want. With some extra effort you can get the old to talk to the new. Consider a Swift only protocol that just needs to use a tuple:</p>

<pre><code class="swift">protocol Legend {

    func doSomething() -&gt; (String, String)

}

class IAmLegend: Legend {

    func doSomething() -&gt; (String, String) {
        return ("very", "important")
    }

}

func doSomethingWithLegend(legend: Legend) {
    let (first, second) = legend.doSomething()
    // Do something else with these variables
}
</code></pre>

<p>Important stuff going on. You get the idea. But obviously you won&rsquo;t be able to call that from any existing code.</p>

<pre><code class="swift">@objc class Compatible {

    let first: String
    let second: String

    init(first: String, second: String) {
        self.first = first
        self.second = second
    }

}

class LegendSwiftAdapter: Legend {

    let compatible: Compatible

    init(compatible: Compatible) {
        self.compatible = compatible
    }

    func doSomething() -&gt; (String, String) {
         return (compatible.first, compatible.second)
    }

}

@objc class LegendObjcAdapter {

    func doSomethingWithATuple(compatible: Compatible) {
        let adapter = LegendSwiftAdapter(compatible)
        doSomethingWithLegend(adapter)
    }

}
</code></pre>

<p>I hope it&rsquo;s somewhat clear what&rsquo;s going on. Contrived example maybe… I&rsquo;ll upload a more practical application soon-ish. Anyways, that&rsquo;s the Adapter Pattern applied in Swift for you. As always the code is available as Xcode playground on <a href="https://github.com/JanGorman/Swift-Design-Patterns">github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns in Swift: Command]]></title>
    <link href="http://JanGorman.github.io/blog/2014/11/17/design-patterns-in-swift-command/"/>
    <updated>2014-11-17T21:19:18+01:00</updated>
    <id>http://JanGorman.github.io/blog/2014/11/17/design-patterns-in-swift-command</id>
    <content type="html"><![CDATA[<p>Continuing on in the series, lets have a look at the Command Pattern and how to implement it in Swift. As <a href="http://en.wikipedia.org/wiki/Command_pattern">Wikipedia</a> so eloquently defines it</p>

<p><blockquote><p>In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to represent and encapsulate all the information needed to call a method at a later time.</p></blockquote></p>

<p>The encapsulation part is key. Say you have a bunch of different objects that can all do <em>something</em> and you want to expose those in a unified kind of way then the command pattern is your friend. Another great feature is that it allows for undos of those actions as you can keep a stack of the commands you ran and just pop them off the stack with an undo method. So what does that look like? First you define your command protocol:</p>

<pre><code class="swift">protocol Command {

    func execute()
    func undo()

}
</code></pre>

<p>Easy enough. Lets get concrete:</p>

<pre><code class="swift">class Light {

    func on() {
        println("The light is on")
    }

    func off() {
        println("The light is off")
    }

}

class LightCommand: Command {

    let light: Light

    init(light: Light) {
        self.light = light
    }

    func execute() {
        light.on()
    }

    func undo() {
        light.off()
    }

}
</code></pre>

<p>Apart from producing a bunch of code that wraps the obvious nothing magic has happened yet. But now imagine you have some other appliance that also has an on/off kind of functionality but with different method signatures:</p>

<pre><code class="swift">class Heating {

    func turnUp(degrees: Int) {
        println("The heating is set to \(degrees)°C")
    }

    func turnOff() {
        println("The heating is off")
    }

}

class HeatingCommand: Command {

    let heating: Heating

    init(heating: Heating) {
        self.heating = heating
    }

    func execute() {
        heating.turnUp(23)
    }

    func undo() {
        heating.turnOff()
    }

}
</code></pre>

<p>Metric of course.</p>

<p>And it gets neater: There&rsquo;s of course nothing to stop you from bunching together multiple method calls into a single command. So to continue with the home automation theme, you could have a macro type command <code>ArriveAtHomeCommand</code> that switches on a bunch of lights, sets the heating to a comfortable level and switches on the TV.</p>

<p>Too much code! More cryptic! Ok, ok. So you can also do a similar thing using closures that are your commands. The simplified way to define a closure makes that at least a bit more readable than it was in Objective-C:</p>

<pre><code class="swift">typealias CommandClosure = () -&gt; Void

var commands = [CommandClosure]()

let heatingCommand = { () -&gt; Void in
    let heating = Heating()
    heating.turnUp(23)
}

commands.append(heatingCommand)

// Much later
commands[0]()
</code></pre>

<p>That also works. The option to store closures/functions inside of arrays is pretty cool but here you loose the build in undo option. The way around that would be to define both an execute and undo block and whenever you execute a command you push its corresponding undo into your array/stack. But if you&rsquo;re only going one way and can skip the undo, this is a viable way to go.</p>

<p>Again the code is available as Xcode playground on <a href="https://github.com/JanGorman/Swift-Design-Patterns">github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns in Swift: Strategy]]></title>
    <link href="http://JanGorman.github.io/blog/2014/11/09/design-patterns-in-swift-strategy/"/>
    <updated>2014-11-09T10:44:39+01:00</updated>
    <id>http://JanGorman.github.io/blog/2014/11/09/design-patterns-in-swift-strategy</id>
    <content type="html"><![CDATA[<p>As a refresher, I thought it could be fun to look at some common design patterns and how they apply to Swift. One very essential part of the pattern-tool-chest is the strategy pattern. Let&rsquo;s dive straight in.</p>

<p>With the strategy pattern you define algorithms or behavior. You then compose your objects out of those behaviors. How does that look like?</p>

<p>First, your behavior protocol and two possible implementations:</p>

<pre><code class="swift">protocol TapBehavior {

    func tap()

}

class CartTapBehavior: TapBehavior {

    func tap() {
        println("I'm the cart tap")
    }

}

class WishListTapBehavior: TapBehavior {

    func tap() {
        println("I'm the wish list tap")
    }

}
</code></pre>

<p>Which brings up an important point: it&rsquo;s always preferrable to program to a protocol/interface rather than to a concrete implementation.</p>

<p>Next, you&rsquo;d want to actually use the behavior:</p>

<pre><code class="swift">class SomeViewWithAButton: UIView {

    @IBOutlet weak var aButton: UIButton!

    var tapBehavior: TapBehavior?

    @IBAction func didTapButton(sender: AnyObject) {
        tapBehavior?.tap()
    }

}
</code></pre>

<p>By making the behavior a property of the class it is now easy to add and replace behaviors at runtime. You might begin to see how this can lead to very flexible designs. A different approach here could have been to create an abstract base view and then create two concrete implementations for different tap behaviors but as soon as you need a new kind of behavior you&rsquo;d be forced to create a new subclass. And now imagine that you have  multiple behaviors in a class – the subclass approach would lead to all kinds of combinations of subclasses that each have to implement variations of behavior.</p>

<p>Even if this is an extremely simple pattern, it&rsquo;s good to keep it in mind the next time you have to implement varying behavior in some kind of base class. Would composing work better than inheriting?</p>

<p>A full example is available as Xcode playground on <a href="https://github.com/JanGorman/Swift-Design-Patterns">github</a></p>
]]></content>
  </entry>
  
</feed>
