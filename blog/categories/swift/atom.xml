<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Jan Gorman]]></title>
  <link href="http://JanGorman.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://JanGorman.github.io/"/>
  <updated>2014-11-09T11:53:07+01:00</updated>
  <id>http://JanGorman.github.io/</id>
  <author>
    <name><![CDATA[Jan Gorman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Design Patterns in Swift: Strategy]]></title>
    <link href="http://JanGorman.github.io/blog/2014/11/09/design-patterns-in-swift-strategy/"/>
    <updated>2014-11-09T10:44:39+01:00</updated>
    <id>http://JanGorman.github.io/blog/2014/11/09/design-patterns-in-swift-strategy</id>
    <content type="html"><![CDATA[<p>As a refresher, I thought it could be fun to look at some common design patterns and how they apply to Swift. One very essential part of the pattern-tool-chest is the strategy pattern. Let&rsquo;s dive straight in.</p>

<p>With the strategy pattern you define algorithms or behavior. You then compose your objects out of those behaviors. How does that look like?</p>

<p>First, your behavior protocol and two possible implementations:</p>

<pre><code>protocol TapBehavior {

    func tap()

}

class CartTapBehavior: TapBehavior {

    func tap() {
        println("I'm the cart tap")
    }

}

class WishListTapBehavior: TapBehavior {

    func tap() {
        println("I'm the wish list tap")
    }

}
</code></pre>

<p>Which brings up an important point: it&rsquo;s always preferrable to program to a protocol/interface rather than to a concrete implementation.</p>

<p>Next, you&rsquo;d want to actually use the behavior:</p>

<pre><code>class SomeViewWithAButton: UIView {

    @IBOutlet weak var aButton: UIButton!

    var tapBehavior: TapBehavior?

    @IBAction func didTapButton(sender: AnyObject) {
        tapBehavior?.tap()
    }

}
</code></pre>

<p>By making the behavior a property of the class it is now easy to add and replace behaviors at runtime. You might begin to see how this can lead to very flexible designs. A different approach here could have been to create an abstract base view and then create two concrete implementations for different tap behaviors but as soon as you need a new kind of behavior you&rsquo;d be forced to create a new subclass. And now imagine that you have  multiple behaviors in a class â€“ the subclass approach would lead to all kinds of combinations of subclasses that each have to implement variations of behavor.</p>

<p>Even if this is an extremely simple pattern, it&rsquo;s good to keep it in mind the next time you have to implement varying behavior in some kind of base class. Would composing work better than inheriting?</p>

<p>A full example is available as Xcode playground on <a href="https://github.com/JanGorman/Swift-Design-Patterns">github</a></p>
]]></content>
  </entry>
  
</feed>
